package main

import (
	"fmt"
	"os"
	"strconv"
	"time"

	"github.com/tealeg/xlsx"
)

var scriptIDs = []string{
	"5c3cc5f8-6773-40f4-b38e-39a37a815873",
	"5c3cc5f8-6773-40f4-b38e-39a37a817374",
	"b4b06180-f418-4311-b6f6-46410b0321c9",
	"00c3a9c0-640c-4d88-a3e6-64713fd71343",
	"05ffa35d-e616-46f4-b943-bd4a9b5ad873",
	"088424cf-d8ec-46e4-8647-bee13658d3c2",
	"538d4b6f-79a2-4432-aa37-4db9616fb928",
	"6a0e9502-6d2e-43f2-a033-d05114c0ae03",
	"7ea1905e-f27d-404f-affd-f38ca8177c75",
	"997682da-771b-40b1-b46d-a693d7b19545",
	"e3faa75a-8690-461d-9e0f-4334b4aa8a4e",
	"66a06011-b97a-4447-8968-c64d70f34fa3",
	"c704ead5-82df-4faa-8986-cfa1a4b9a250",
}

const (
	dataExcelTabIndex = 1
	endPointOffset    = 7
	totalRowSize      = 71
	dateToday         = "18Jan18"
)

var upFileName string
var downFileName string
var upCounter int
var downCounter int
var timestamp int

func main() {
	t := time.Now()
	time, err := strconv.Atoi(t.Format("20060102150405"))
	if err != nil {
		fmt.Println(err)
		return
	}
	timestamp = time
	createDirIfNotExist("output")
	readDataFile()
	fmt.Println("Total Up Record=", upCounter)
	fmt.Println("Total Up Row=", upCounter/len(scriptIDs))
	fmt.Println("Total Down Record=", downCounter)
	fmt.Println("Total Down Row=", downCounter/len(scriptIDs))
}

func readDataFile() {
	excelFileName := "data.xlsx"
	xlFile, err := xlsx.OpenFile(excelFileName)
	if err != nil {
		fmt.Println(err)
	}
	fmt.Println("file open success")
	for index, sheet := range xlFile.Sheets {
		if index != dataExcelTabIndex {
			continue
		}
		for rowIndex, row := range sheet.Rows {
			if rowIndex >= totalRowSize {
				break
			}
			if rowIndex%endPointOffset == 0 {
				createOutputFile(rowIndex)
			}
			if rowIndex == 0 {
				// Ignore header row
				continue
			}
			var partnerData []string
			for _, cell := range row.Cells {
				text := cell.String()
				partnerData = append(partnerData, text)
			}
			createCqlsFile(partnerData)
		}
	}
}

func createOutputFile(rowIndex int) error {
	if rowIndex > 0 {
		appendFileFooter(upFileName)
		appendFileFooter(downFileName)
	}
	timestamp += 2
	batch := (rowIndex / 7) + 1
	upFileName = fmt.Sprintf("output/%v_partner_endpoint_mapping_prod_Batch%d_%s.up", timestamp, batch, dateToday)
	downFileName = fmt.Sprintf("output/%v_partner_endpoint_mapping_prod_Batch%d_%s.down", timestamp, batch, dateToday)
	deleteFile(upFileName)
	deleteFile(downFileName)
	err := createFile(upFileName)
	if err != nil {
		return err
	}
	appendFileHeader(upFileName)
	err = createFile(downFileName)
	if err != nil {
		return err
	}
	appendFileHeader(downFileName)
	return err
}

func appendFileHeader(fileName string) {
	writeFile(fileName, "//")
	writeFile(fileName, "// ATTENTION!!! DO NOT EDIT THIS FILE. IT IS CREATED FOLLOWING SCHEMA MIGRATION STRATEGY")
	writeFile(fileName, "//")
	writeFile(fileName, "BEGIN BATCH")
}

func appendFileFooter(fileName string) {
	writeFile(fileName, "APPLY BATCH")
}

func createCqlsFile(rowData []string) {
	fmt.Println(rowData)
	endpointid := rowData[0]
	partnerid := rowData[1]
	siteid := rowData[2]
	regid := rowData[3]
	resourcetype := rowData[4]
	isExecuted := "FALSE"
	for index := range scriptIDs {
		scriptid := scriptIDs[index]
		result := fmt.Sprintf("INSERT INTO partner_endpoint_mapping(id, endpointid, partnerid, siteid, regid, resourcetype, scriptid, isexecuted) VALUES (now(), %s, '%s', '%s', '%s', '%s', %s, %s);", endpointid, partnerid, siteid, regid, resourcetype, scriptid, isExecuted)
		err := writeFile(upFileName, result)
		if err != nil {
			fmt.Println("error in writing up file", err)
		}
		upCounter++
		result = fmt.Sprintf("DELETE FROM partner_endpoint_mapping WHERE partnerid = '%s' AND siteid = '%s' AND endpointid = %s AND scriptid = %s;", partnerid, siteid, endpointid, scriptid)
		err = writeFile(downFileName, result)
		if err != nil {
			fmt.Println("error in writing down file", err)
		}
		downCounter++
	}
}

func writeFile(path string, msg string) error {
	// open file using READ & WRITE permission
	var file, err = os.OpenFile(path, os.O_RDWR|os.O_APPEND, 0644)
	if err != nil {
		return err
	}
	defer file.Close()

	// write some text line-by-line to file
	_, err = file.WriteString(msg)
	if err != nil {
		return err
	}
	_, err = file.WriteString("\n\n")
	if err != nil {
		return err
	}

	// save changes
	err = file.Sync()
	return err
}

func createFile(fileName string) error {
	// detect if file exists
	var _, err = os.Stat(fileName)

	// create file if not exists
	if os.IsNotExist(err) {
		var file, err = os.Create(fileName)
		if err != nil {
			return err
		}
		defer file.Close()
	}
	return nil
}

func deleteFile(path string) error {
	// delete file
	var err = os.Remove(path)
	if err != nil {
		return err
	}
	return nil
}

func createDirIfNotExist(dir string) {
	_, err := os.Stat(dir)
	if !os.IsNotExist(err) {
		os.Remove(dir)
	}
	if os.IsNotExist(err) {
		err = os.MkdirAll(dir, 0755)
		if err != nil {
			panic(err)
		}
	}
}
